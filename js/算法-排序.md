
| 排序类型 | 执行效率 | 内存消耗 | 稳定性 | 代码实现 |
|---|---|---|---|---|
| | 1、最好情况、最坏情况、平均情况时间复杂度<br />2、时间复杂度的系数、常数、低阶<br />3、比较次数和交换（或移动）次数| 1、排序算法的空间复杂度，需要通过原地排序来分析<br />2、原地排序算法特指空间复杂度是O(1)的排序算法 | 稳定排序算法可以保持数据相同的两个对象，在排序之后的前后顺序不变 | |
| 冒泡排序 | 最好情况时间复杂度是O(n)<br />最坏情况时间复杂度O(n<sup>2</sup>) | 空间复杂度是O(1),是原地排序算法 | 稳定 | [code](#冒泡排序) |
| 插入排序 | 1、有序数组：最好情况复杂度为O(n)<br />2、倒序数组：最坏情况时间复杂度为O(n<sup>2</sup>)<br />3、插入数据：平均时间复杂度为O(n<sup>2</sup>) | 空间复杂度是O(1)，是原地排序算法 | 稳定 | code |
| 选择排序 | 最好情况时间复杂度、最坏情况时间和平均情况时间复杂度都为O(n<sup>2</sup>) | 空间复杂度是O(1)，是原地排序算法 | 不稳定 | code |
| 归并排序 | 最好情况、最坏情况和平均情况时间复杂度都是O(nlogn) | 空间复杂度比较高是O(n)，不是原地排序算法 | 稳定 | code |
| 快速排序 | 平均情况时间复杂度是O(nlogn)，最坏情况下的时间复杂度是O(n<sup>2</sup>) | 空间复杂度是O(1)，是原地排序算法 | 不稳定 | code |



### 冒泡排序
```js

```